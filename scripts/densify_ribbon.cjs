// scripts/densify_ribbon.js
// Usage:
//   node scripts/densify_ribbon.js src/lib/ligne050_ribbon.ts src/lib/ligne050_ribbon_dense.ts 0.025
//
// stepKm = 0.025 => 25 m

const fs = require("fs");

function parseRibbonFromTs(tsText) {
  // Extrait tous les objets { s_km: X, lat: Y, lon: Z }
  // Tolère espaces, virgules, points.
  const re = /\{\s*s_km:\s*([0-9]+(?:\.[0-9]+)?)\s*,\s*lat:\s*([0-9]+(?:\.[0-9]+)?)\s*,\s*lon:\s*([0-9]+(?:\.[0-9]+)?)\s*\}/g;
  const pts = [];
  let m;
  while ((m = re.exec(tsText)) !== null) {
    pts.push({
      s_km: Number(m[1]),
      lat: Number(m[2]),
      lon: Number(m[3]),
    });
  }
  return pts;
}

function densifyBySkm(points, stepKm) {
  if (!Array.isArray(points) || points.length < 2) return points;

  const out = [];
  let nonMonotonicCount = 0;
  let flatCount = 0;

  for (let i = 0; i < points.length - 1; i++) {
    const a = points[i];
    const b = points[i + 1];

    out.push(a);

    const ds = b.s_km - a.s_km;

    if (!(Number.isFinite(ds))) continue;

    if (ds < 0) {
      nonMonotonicCount++;
      // On n’interpole pas si s_km recule (ça indiquerait un ruban pas monotone).
      continue;
    }
    if (ds === 0) {
      flatCount++;
      continue;
    }

    // On ajoute des points intermédiaires tous les stepKm (sans dépasser b)
    // Exemple: a=10.000, b=10.100, step=0.025 => 10.025, 10.050, 10.075
    const n = Math.floor(ds / stepKm);
    for (let k = 1; k <= n; k++) {
      const s = a.s_km + k * stepKm;
      if (s >= b.s_km) break;

      const t = (s - a.s_km) / ds; // 0..1
      const lat = a.lat + t * (b.lat - a.lat);
      const lon = a.lon + t * (b.lon - a.lon);

      out.push({
        s_km: s,
        lat,
        lon,
      });
    }
  }

  // Dernier point
  out.push(points[points.length - 1]);

  return { out, nonMonotonicCount, flatCount };
}

function formatTs(points, meta) {
  const lines = [];
  lines.push(`// Dense ribbon for LAV 050 Can Tunis → Frontière`);
  lines.push(`// Generated by scripts/densify_ribbon.js`);
  lines.push(`// Step: ${meta.stepKm} km (${Math.round(meta.stepKm * 1000)} m)`);
  lines.push(`// Original points: ${meta.originalCount} | Dense points: ${meta.denseCount}`);
  if (meta.nonMonotonicCount > 0) {
    lines.push(`// ⚠️ Warning: non-monotonic s_km segments: ${meta.nonMonotonicCount} (no interpolation applied on those)`);
  }
  if (meta.flatCount > 0) {
    lines.push(`// Note: flat s_km segments (ds=0): ${meta.flatCount}`);
  }
  lines.push("");
  lines.push("export type RibbonPoint = {");
  lines.push("  s_km: number;");
  lines.push("  lat: number;");
  lines.push("  lon: number;");
  lines.push("};");
  lines.push("");
  lines.push("export const RIBBON_POINTS: RibbonPoint[] = [");

  for (const p of points) {
    // on garde 3 décimales sur s_km (=> mètre) et 7 décimales sur lat/lon
    const s = p.s_km.toFixed(3);
    const lat = p.lat.toFixed(7);
    const lon = p.lon.toFixed(7);
    lines.push(`  { s_km: ${s}, lat: ${lat}, lon: ${lon} },`);
  }

  lines.push("];");
  lines.push("");
  return lines.join("\n");
}

function main() {
  const inPath = process.argv[2];
  const outPath = process.argv[3];
  const stepKm = Number(process.argv[4] ?? "0.025");

  if (!inPath || !outPath) {
    console.error("Usage: node densify_ribbon.js <input.ts> <output.ts> <stepKm>");
    process.exit(1);
  }
  if (!Number.isFinite(stepKm) || stepKm <= 0) {
    console.error("Invalid stepKm:", stepKm);
    process.exit(1);
  }

  const text = fs.readFileSync(inPath, "utf8");
  const pts = parseRibbonFromTs(text);

  if (pts.length < 2) {
    console.error("Could not parse enough points from:", inPath, "parsed:", pts.length);
    process.exit(1);
  }

  const r = densifyBySkm(pts, stepKm);
  const densePts = r.out;

  const tsOut = formatTs(densePts, {
    stepKm,
    originalCount: pts.length,
    denseCount: densePts.length,
    nonMonotonicCount: r.nonMonotonicCount,
    flatCount: r.flatCount,
  });

  fs.writeFileSync(outPath, tsOut, "utf8");

  console.log("[densify] input:", inPath);
  console.log("[densify] output:", outPath);
  console.log("[densify] stepKm:", stepKm, `(${Math.round(stepKm * 1000)} m)`);
  console.log("[densify] points:", pts.length, "->", densePts.length);
  if (r.nonMonotonicCount > 0) {
    console.warn("[densify] WARNING non-monotonic segments:", r.nonMonotonicCount);
  }
  if (r.flatCount > 0) {
    console.warn("[densify] NOTE flat segments (ds=0):", r.flatCount);
  }
}

main();
